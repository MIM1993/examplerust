{"message":"unused import: `std::net::Shutdown::Write`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":23,"byte_end":48,"line_start":2,"line_end":2,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use std::net::Shutdown::Write;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":19,"byte_end":49,"line_start":2,"line_end":2,"column_start":1,"column_end":31,"is_primary":true,"text":[{"text":"use std::net::Shutdown::Write;","highlight_start":1,"highlight_end":31}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::net::Shutdown::Write`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:2:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::net::Shutdown::Write;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"trait objects without an explicit `dyn` are deprecated","code":{"code":"bare_trait_objects","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":4588,"byte_end":4602,"line_start":277,"line_end":277,"column_start":29,"column_end":43,"is_primary":true,"text":[{"text":"    fn returns_closure() -> Fn(i32) -> i32 {","highlight_start":29,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(bare_trait_objects)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `dyn`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4588,"byte_end":4602,"line_start":277,"line_end":277,"column_start":29,"column_end":43,"is_primary":true,"text":[{"text":"    fn returns_closure() -> Fn(i32) -> i32 {","highlight_start":29,"highlight_end":43}],"label":null,"suggested_replacement":"dyn Fn(i32) -> i32","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: trait objects without an explicit `dyn` are deprecated\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:277:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m277\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn returns_closure() -> Fn(i32) -> i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: use `dyn`: `dyn Fn(i32) -> i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(bare_trait_objects)]` on by default\u001b[0m\n\n"}
{"message":"return type cannot have an unboxed trait object","code":{"code":"E0746","explanation":"An unboxed trait object was used as a return value.\n\nErroneous code example:\n\n```compile_fail,E0746\ntrait T {\n    fn bar(&self);\n}\nstruct S(usize);\nimpl T for S {\n    fn bar(&self) {}\n}\n\n// Having the trait `T` as return type is invalid because\n// unboxed trait objects do not have a statically known size:\nfn foo() -> dyn T { // error!\n    S(42)\n}\n```\n\nReturn types cannot be `dyn Trait`s as they must be `Sized`.\n\nTo avoid the error there are a couple of options.\n\nIf there is a single type involved, you can use [`impl Trait`]:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n// The compiler will select `S(usize)` as the materialized return type of this\n// function, but callers will only know that the return type implements `T`.\nfn foo() -> impl T { // ok!\n    S(42)\n}\n```\n\nIf there are multiple types involved, the only way you care to interact with\nthem is through the trait's interface, and having to rely on dynamic dispatch\nis acceptable, then you can use [trait objects] with `Box`, or other container\ntypes like `Rc` or `Arc`:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\nstruct O(&'static str);\nimpl T for O {\n    fn bar(&self) {}\n}\n\n// This now returns a \"trait object\" and callers are only be able to access\n// associated items from `T`.\nfn foo(x: bool) -> Box<dyn T> { // ok!\n    if x {\n        Box::new(S(42))\n    } else {\n        Box::new(O(\"val\"))\n    }\n}\n```\n\nFinally, if you wish to still be able to access the original type, you can\ncreate a new `enum` with a variant for each type:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\nenum E {\n    S(S),\n    O(O),\n}\n\n// The caller can access the original types directly, but it needs to match on\n// the returned `enum E`.\nfn foo(x: bool) -> E {\n    if x {\n        E::S(S(42))\n    } else {\n        E::O(O(\"val\"))\n    }\n}\n```\n\nYou can even implement the `trait` on the returned `enum` so the callers\n*don't* have to match on the returned value to invoke the associated items:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\n# enum E {\n#     S(S),\n#     O(O),\n# }\nimpl T for E {\n    fn bar(&self) {\n        match self {\n            E::S(s) => s.bar(),\n            E::O(o) => o.bar(),\n        }\n    }\n}\n```\n\nIf you decide to use trait objects, be aware that these rely on\n[dynamic dispatch], which has performance implications, as the compiler needs\nto emit code that will figure out which method to call *at runtime* instead of\nduring compilation. Using trait objects we are trading flexibility for\nperformance.\n\n[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4588,"byte_end":4602,"line_start":277,"line_end":277,"column_start":29,"column_end":43,"is_primary":true,"text":[{"text":"    fn returns_closure() -> Fn(i32) -> i32 {","highlight_start":29,"highlight_end":43}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `impl Fn(i32) -> i32` as the return type, as all return paths are of type `[closure@src/main.rs:278:9: 278:18]`, which implements `Fn(i32) -> i32`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4588,"byte_end":4602,"line_start":277,"line_end":277,"column_start":29,"column_end":43,"is_primary":true,"text":[{"text":"    fn returns_closure() -> Fn(i32) -> i32 {","highlight_start":29,"highlight_end":43}],"label":null,"suggested_replacement":"impl Fn(i32) -> i32","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0746]\u001b[0m\u001b[0m\u001b[1m: return type cannot have an unboxed trait object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:277:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m277\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn returns_closure() -> Fn(i32) -> i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `impl Fn(i32) -> i32` as the return type, as all return paths are of type `[closure@src/main.rs:278:9: 278:18]`, which implements `Fn(i32) -> i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m277\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn returns_closure() -> impl Fn(i32) -> i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `std::ops::Add`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":4,"byte_end":17,"line_start":1,"line_end":1,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"use std::ops::Add;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::ops::Add`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::ops::Add;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"aborting due to previous error; 3 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error; 3 warnings emitted\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0746`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0746`.\u001b[0m\n"}
